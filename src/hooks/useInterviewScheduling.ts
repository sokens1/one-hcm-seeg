import { useState, useEffect, useCallback, useRef, useMemo } from 'react';

interface LinkedUserRecord {
  first_name?: string;
  last_name?: string;
}

interface LinkedJobOfferRecord {
  title?: string;
}

interface ApplicationDetails {
  candidate_id?: string | null;
  job_offer_id?: string | null;
  users?: LinkedUserRecord | LinkedUserRecord[];
  job_offers?: LinkedJobOfferRecord | LinkedJobOfferRecord[];
}
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/components/ui/use-toast';
import { useAuth } from '@/hooks/useAuth';

export interface InterviewSlot {
  id?: string;
  date: string; // Format YYYY-MM-DD
  time: string; // Format HH:MM:SS
  isAvailable: boolean;
  applicationId?: string;
  recruiterId?: string;
  candidateId?: string;
  createdAt?: string;
  updatedAt?: string;
}

export interface InterviewSchedule {
  date: string;
  slots: InterviewSlot[];
}

export const useInterviewScheduling = (applicationId?: string) => {
  const [schedules, setSchedules] = useState<InterviewSchedule[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const { toast } = useToast();
  const { user } = useAuth();
  const loadingTimeoutRef = useRef<NodeJS.Timeout>();
  const lastApplicationIdRef = useRef<string>();

  // Normalisation de l'heure au format HH:MM:SS
  const normalizeTimeToHms = useCallback((value: string): string => {
    const trimmed = (value || '').trim();
    const hms = /^([01]?\d|2[0-3]):([0-5]\d):([0-5]\d)$/; // HH:MM:SS
    const hm = /^([01]?\d|2[0-3]):([0-5]\d)$/; // HH:MM
    if (hms.test(trimmed)) return trimmed;
    if (hm.test(trimmed)) return `${trimmed}:00`;
    // Tentative de rattrapage 9:0 -> 09:00:00
    const parts = trimmed.split(':').map(p => p.padStart(2, '0'));
    if (parts.length === 2) return `${parts[0]}:${parts[1]}:00`;
    if (parts.length === 3) return `${parts[0]}:${parts[1]}:${parts[2]}`;
    return trimmed; // on laisse tel quel, la DB rejettera si invalide
  }, []);

  // Cr√©neaux horaires disponibles (align√©s sur HH:MM:SS)
  const timeSlots = useMemo(() => (
    ['09:00:00', '10:00:00', '11:00:00', '14:00:00', '15:00:00', '16:00:00', '17:00:00']
  ), []);

  // Charger les cr√©neaux d'entretien
  const loadInterviewSlots = useCallback(async () => {
    if (!applicationId) return;

    // Cache simple pour √©viter les rechargements inutiles
    const cacheKey = `slots_${applicationId}`;
    const cachedData = sessionStorage.getItem(cacheKey);
    const cacheTime = sessionStorage.getItem(`${cacheKey}_time`);
    
    // Utiliser le cache si il a moins de 30 secondes
    if (cachedData && cacheTime && (Date.now() - parseInt(cacheTime)) < 30000) {
      try {
        const parsedData = JSON.parse(cachedData);
        setSchedules(parsedData);
        setIsLoading(false);
        console.log('üì¶ Donn√©es charg√©es depuis le cache');
        return;
      } catch (e) {
        console.log('‚ùå Cache invalide, rechargement...');
      }
    }

    // √âviter les appels multiples pour la m√™me application
    if (lastApplicationIdRef.current === applicationId && schedules.length > 0) {
      console.log('‚è≠Ô∏è Chargement ignor√© - donn√©es d√©j√† pr√©sentes pour:', applicationId);
      return;
    }

    // Annuler le timeout pr√©c√©dent s'il existe
    if (loadingTimeoutRef.current) {
      clearTimeout(loadingTimeoutRef.current);
    }

    setIsLoading(true);
    lastApplicationIdRef.current = applicationId;
    
    try {
      console.log('üîÑ Chargement des cr√©neaux pour application:', applicationId);
      
      // R√©cup√©rer seulement les cr√©neaux n√©cessaires avec une requ√™te optimis√©e
      const { data, error } = await supabase
        .from('interview_slots')
        .select('id, date, time, is_available, application_id, recruiter_id, candidate_id, created_at, updated_at')
        .or(`is_available.eq.true,application_id.eq.${applicationId}`)
        .gte('date', new Date().toISOString().split('T')[0]) // Seulement les dates futures
        .order('date', { ascending: true })
        .limit(100); // Limiter le nombre de r√©sultats

      if (error) {
        console.error('‚ùå Erreur Supabase:', error);
        throw error;
      }

      console.log('‚úÖ Donn√©es re√ßues:', data);

      // Optimisation : Organiser les cr√©neaux par date avec Map plus efficace
      const schedulesMap = new Map<string, Map<string, InterviewSlot>>();
      
      data?.forEach(slot => {
        const date = slot.date;
        const time = slot.time;
        
        if (!schedulesMap.has(date)) {
          schedulesMap.set(date, new Map());
        }
        
        schedulesMap.get(date)!.set(time, {
          id: slot.id,
          date: slot.date,
          time: slot.time,
          isAvailable: slot.is_available,
          applicationId: slot.application_id,
          recruiterId: slot.recruiter_id,
          candidateId: slot.candidate_id,
          createdAt: slot.created_at,
          updatedAt: slot.updated_at
        });
      });

      // Convertir en array avec g√©n√©ration optimis√©e des cr√©neaux manquants
      const schedules: InterviewSchedule[] = [];
      schedulesMap.forEach((timeMap, date) => {
        const allSlots: InterviewSlot[] = timeSlots.map(time => {
          return timeMap.get(time) || {
            date,
            time,
            isAvailable: true,
            applicationId: undefined
          };
        });
        schedules.push({ date, slots: allSlots });
      });

      console.log('üìÖ Schedules g√©n√©r√©s:', schedules);
      
      // Mettre en cache les donn√©es pour 30 secondes
      try {
        sessionStorage.setItem(cacheKey, JSON.stringify(schedules));
        sessionStorage.setItem(`${cacheKey}_time`, Date.now().toString());
      } catch (e) {
        console.log('‚ö†Ô∏è Impossible de mettre en cache');
      }
      
      setSchedules(schedules);
    } catch (error) {
      console.error('‚ùå Erreur lors du chargement des cr√©neaux:', error);
      toast({
        title: "Erreur",
        description: "Impossible de charger les cr√©neaux d'entretien",
        variant: "destructive",
      });
    } finally {
      // D√©lai pour √©viter les changements d'√©tat trop rapides
      loadingTimeoutRef.current = setTimeout(() => {
        setIsLoading(false);
      }, 200);
    }
  }, [applicationId, toast, schedules.length, timeSlots]);

  // Programmer un entretien
  const scheduleInterview = useCallback(async (date: string, time: string) => {
    if (!applicationId || !user) return false;

    setIsSaving(true);
    try {
      const normalizedTime = normalizeTimeToHms(time);
      console.log('üîÑ Programmation entretien pour:', { date, time: normalizedTime, applicationId, userId: user.id });

      // R√©cup√©rer les informations du job et du candidat pour remplir les champs obligatoires
      const { data: applicationDetails, error: appDetailsError } = await supabase
        .from('applications')
        .select(`
          candidate_id,
          job_offer_id,
          users:users!applications_candidate_id_fkey(first_name, last_name),
          job_offers:job_offers!applications_job_offer_id_fkey(title)
        `)
        .eq('id', applicationId)
        .single();

      if (appDetailsError) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des d√©tails:', appDetailsError);
        throw appDetailsError;
      }

      // Certains retours de jointure peuvent √™tre typ√©s comme des tableaux
      const appDet = applicationDetails as unknown as ApplicationDetails;
      const usersField = appDet.users;
      const jobOffersField = appDet.job_offers;
      const userRecord: LinkedUserRecord | undefined = Array.isArray(usersField) ? usersField[0] : usersField;
      const jobOfferRecord: LinkedJobOfferRecord | undefined = Array.isArray(jobOffersField) ? jobOffersField[0] : jobOffersField;

      const candidateName = `${userRecord?.first_name || ''} ${userRecord?.last_name || ''}`.trim();
      const jobTitle = jobOfferRecord?.title || 'Poste non sp√©cifi√©';

      console.log('üìã D√©tails r√©cup√©r√©s:', { candidateName, jobTitle, candidateId: applicationDetails.candidate_id });

      // V√©rifier si le cr√©neau existe d√©j√† et s'il est occup√©
      const { data: existingSlot, error: checkError } = await supabase
        .from('interview_slots')
        .select('id, application_id, is_available')
        .eq('date', date)
        .eq('time', normalizedTime)
        .single();

      if (checkError && checkError.code !== 'PGRST116') { // PGRST116 = no rows returned
        console.error('‚ùå Erreur lors de la v√©rification du cr√©neau:', checkError);
        throw checkError;
      }

      // Si le cr√©neau existe et est occup√© par une autre application
      if (existingSlot && existingSlot.application_id && existingSlot.application_id !== applicationId && !existingSlot.is_available) {
        toast({
          title: "Cr√©neau occup√©",
          description: "Ce cr√©neau est d√©j√† r√©serv√© par une autre candidature",
          variant: "destructive",
        });
        return false;
      }

      let insertError;
      if (existingSlot) {
        // Mettre √† jour le cr√©neau existant
        const { error } = await supabase
          .from('interview_slots')
          .update({
            application_id: applicationId,
            candidate_name: candidateName,
            job_title: jobTitle,
            status: 'scheduled',
            is_available: false,
            recruiter_id: user.id,
            candidate_id: applicationDetails.candidate_id,
            notes: 'Entretien programm√©',
            updated_at: new Date().toISOString()
          })
          .eq('id', existingSlot.id);
        insertError = error;
      } else {
        // Cr√©er ou mettre √† jour via upsert en cas de conflit (date,time).
        // Si l'upsert renvoie 400 (contrainte unique manquante), fallback insert->update en cas de doublon.
        let upsertError;
        try {
          const { error } = await supabase
            .from('interview_slots')
            .upsert({
              date,
              time: normalizedTime,
              application_id: applicationId,
              candidate_name: candidateName,
              job_title: jobTitle,
              status: 'scheduled',
              is_available: false,
              recruiter_id: user.id,
              candidate_id: applicationDetails.candidate_id,
              notes: 'Entretien programm√©',
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            }, { onConflict: 'date,time' });
          upsertError = error;
        } catch (e) {
          // cas rare: throw r√©seau
          upsertError = e as unknown as { code?: string; message?: string };
        }

        if (upsertError) {
          // Fallback: tentative d'insert simple
          const { error: insErr } = await supabase
            .from('interview_slots')
            .insert({
              date,
              time: normalizedTime,
              application_id: applicationId,
              candidate_name: candidateName,
              job_title: jobTitle,
              status: 'scheduled',
              is_available: false,
              recruiter_id: user.id,
              candidate_id: applicationDetails.candidate_id,
              notes: 'Entretien programm√©',
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            });

          if (insErr && (insErr as unknown as { code?: string }).code === '23505') {
            // Doublon: Update du slot existant sur (date,time)
            const { error: updErr } = await supabase
              .from('interview_slots')
              .update({
                application_id: applicationId,
                candidate_name: candidateName,
                job_title: jobTitle,
                status: 'scheduled',
                is_available: false,
                recruiter_id: user.id,
                candidate_id: applicationDetails.candidate_id,
                notes: 'Entretien programm√©',
                updated_at: new Date().toISOString()
              })
              .eq('date', date)
              .eq('time', normalizedTime);
            insertError = updErr;
          } else {
            insertError = insErr;
          }
        } else {
          insertError = undefined;
        }
      }

      if (insertError) {
        console.error('‚ùå Erreur lors de la cr√©ation du cr√©neau:', insertError);
        throw insertError;
      }

      // Invalider le cache apr√®s une programmation r√©ussie
      const cacheKey = `slots_${applicationId}`;
      sessionStorage.removeItem(cacheKey);
      sessionStorage.removeItem(`${cacheKey}_time`);

      // Mettre √† jour l'application avec la date d'entretien
      const interviewDateTime = new Date(`${date}T${normalizedTime}`);
      const { error: updateError } = await supabase
        .from('applications')
        .update({
          interview_date: interviewDateTime.toISOString(),
          status: 'entretien_programme',
          updated_at: new Date().toISOString()
        })
        .eq('id', applicationId);

      if (updateError) {
        console.error('‚ùå Erreur lors de la mise √† jour de l\'application:', updateError);
        throw updateError;
      }

      toast({
        title: "Entretien programm√©",
        description: `F√©licitations, votre candidature a √©t√© retenue. Vous avez un entretien programm√© pour le ${new Date(date).toLocaleDateString('fr-FR')} √† ${normalizedTime.slice(0,5)} suite √† votre candidature pour le poste de ${jobTitle}`,
      });

      // Recharger les cr√©neaux
      lastApplicationIdRef.current = undefined; // Force le rechargement
      await loadInterviewSlots();
      return true;
    } catch (error) {
      console.error('‚ùå Erreur lors de la programmation:', error);
      toast({
        title: "Erreur",
        description: "Impossible de programmer l'entretien",
        variant: "destructive",
      });
      return false;
    } finally {
      setIsSaving(false);
    }
  }, [applicationId, user, toast, loadInterviewSlots, normalizeTimeToHms]);

  // Annuler un entretien
  const cancelInterview = useCallback(async (date: string, time: string) => {
    if (!applicationId) return false;

    setIsSaving(true);
    try {
      // Marquer le cr√©neau comme disponible
      const normalizedTime = normalizeTimeToHms(time);
      const { error } = await supabase
        .from('interview_slots')
        .update({
          is_available: true,
          status: 'cancelled',
          recruiter_id: null,
          candidate_id: null,
          notes: 'Cr√©neau lib√©r√©',
          updated_at: new Date().toISOString()
        })
        .eq('date', date)
        .eq('time', normalizedTime)
        .eq('application_id', applicationId);

      if (error) throw error;

      // Mettre √† jour l'application
      const { error: updateError } = await supabase
        .from('applications')
        .update({
          interview_date: null,
          status: 'candidature',
          updated_at: new Date().toISOString()
        })
        .eq('id', applicationId);

      if (updateError) throw updateError;

      toast({
        title: "Entretien annul√©",
        description: "L'entretien a √©t√© annul√©",
      });

      // Recharger les cr√©neaux
      lastApplicationIdRef.current = undefined; // Force le rechargement
      await loadInterviewSlots();
      return true;
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'annulation:', error);
      toast({
        title: "Erreur",
        description: "Impossible d'annuler l'entretien",
        variant: "destructive",
      });
      return false;
    } finally {
      setIsSaving(false);
    }
  }, [applicationId, toast, loadInterviewSlots, normalizeTimeToHms]);

  // V√©rifier si un cr√©neau est occup√©
  const isSlotBusy = useCallback((date: string, time: string) => {
    const schedule = schedules.find(s => s.date === date);
    if (!schedule) return false;
    
    const slot = schedule.slots.find(s => s.time === time);
    return slot ? !slot.isAvailable : false;
  }, [schedules]);

  // V√©rifier si une date est compl√®tement occup√©e
  const isDateFullyBooked = useCallback((date: string) => {
    const schedule = schedules.find(s => s.date === date);
    if (!schedule) return false;
    
    return schedule.slots.every(slot => !slot.isAvailable);
  }, [schedules]);

  // Obtenir les cr√©neaux disponibles pour une date
  const getAvailableSlots = useCallback((date: string) => {
    const schedule = schedules.find(s => s.date === date);
    if (!schedule) return timeSlots;
    
    return schedule.slots
      .filter(slot => slot.isAvailable)
      .map(slot => slot.time);
  }, [schedules, timeSlots]);

  // G√©n√©rer le calendrier pour un mois donn√©
  const generateCalendar = useCallback((date: Date = new Date()) => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDate = new Date(firstDay);
    startDate.setDate(startDate.getDate() - firstDay.getDay());
    
    const days = [];
    const current = new Date(startDate);
    
    // G√©n√©rer 42 jours (6 semaines)
    for (let i = 0; i < 42; i++) {
      days.push(new Date(current));
      current.setDate(current.getDate() + 1);
    }
    
    return { days, firstDay, lastDay };
  }, []);

  // Charger les cr√©neaux au montage du composant
  useEffect(() => {
    loadInterviewSlots();
    
    // Cleanup function
    return () => {
      if (loadingTimeoutRef.current) {
        clearTimeout(loadingTimeoutRef.current);
      }
    };
  }, [loadInterviewSlots]);

  // Fonction pour forcer le rechargement
  const forceReload = useCallback(() => {
    lastApplicationIdRef.current = undefined;
    loadInterviewSlots();
  }, [loadInterviewSlots]);

  return {
    schedules,
    isLoading,
    isSaving,
    timeSlots,
    loadInterviewSlots,
    forceReload,
    scheduleInterview,
    cancelInterview,
    isSlotBusy,
    isDateFullyBooked,
    getAvailableSlots,
    generateCalendar
  };
};
